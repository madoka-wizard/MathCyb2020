\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}

\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}
\usepackage{listings}
\lstset{language=C++,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{green}\ttfamily,
    morecomment=[l][\color{magenta}]{\#}
}

\title{Блокчейн и умные контракты}
\author{Ионин Василий}
\date{}

\begin{document}

\maketitle

\section{Блокчейн}

\textbf{Блокчейн} (\textit{block chain} --- цепь из блоков) --- это технология, которая основана на записи некоторой информации в цепочку блоков, каждый из которых соединен с предыдущими посредством криптографии (например, через хеш-цепочки).

Обычно, каждый блок содержит криптографический хеш (в сети Bitcoin используется двойное применение алгоритма SHA256, подробнее про алгоритм можно \href{https://en.bitcoin.it/wiki/Block_hashing_algorithm}{посмотреть тут}), причем хеш каждого блока в цепи зависит от хеша предыдущего блока. Цепочка считается валидной, если согласованы хеши всех блоков в цепочке (то есть хеш каждого блока такой, что если пересчитать его, учитывая хеш предыдущего блока, получится то же самое). Таким образом, достигается стойкость системы к попыткам изменения (если подменить блок в середине, все последующие хеши инвалидируются).

Чтобы обеспечить когерентность сети, у каждого пользователя блокчейна есть своя копия цепи, и участники ими постоянно обмениваются. То есть блокчейн обычно представляет из себя децентрализованную систему. Если ввести на цепочках функцию оценки, то пользователи сети смогут оставлять у себя локально цепочку с наибольшей оценкой. В качестве оценки зачастую берется количество вычислений, которые должны были быть потрачены на составление (вычисление хешей блоков) данной цепи (PoW, proof-of-work). То есть блокчейн устанавливает соглашение о том, какие события считаются достоверными.

\section{Умные контракты}

\textbf{Умные контракты} (\textit{smart contract}) --- технология, которая основана на блокчейне. Умные контракты представляют собой компьютерный алгоритм, предназначенный для формирования, контроля и предоставления информации о владении чем-либо. Зачастую умный контракт содержит в себе информацию о юридическом контракте (предмет договора, права и обязанности сторон, а также условия вступления договора в силу и условия прекращения действия договора).

Блокчейн позволяет закрепить юридический договор в системе (строится блокчейн, в котором каждый отдельный блок предсавляет собой информацию о контракте). После этого любой пользователь системы блокчейна сможет самостоятельно посмотреть информацию о договоре и, например, проверить, выполнены ли условия вступления договора в силу. К тому же, если условия договора формализуются в виде логической формулы в программе, то стороны вынуждены сформулировать эти условия максимально точно, что может быть полезно, дабы потенциально избежать ложных интерпретаций. Если договор выражает собой право кого-то на владение ресурсом, этот ресурс может быть передан во временное владение самим блоком автоматически в момент вступления договора в силу.

Опишем примерную схему реализации умных контрактов. Мы будем писать блокчейн, который умеет исполнять программный код на каком-либо заданном языке. После того, как сторона составит контракт в виде программы на этом языке, она может добавить его в качестве блока в блокчейн, заплатив какую-то цену. Распределенная сеть потом может выполнять инструкции, прописанные в договоре, получая награду (в качестве примера сети исполнения умного контракта можно привести \href{https://ethereum.org/en/}{Ethereum}). Таким образом, сеть блокчейна обеспечивает выполнение, записанных в него контрактов.

Технология умных контрактов сейчас набирает популярность. Первой страной, законодательно закрепившей смарт-контракты, \href{https://www.belta.by/economics/view/belarus-pervoj-v-mire-zakonodatelno-zakrepila-smart-kontrakt-281784-2017/}{стала Белоруссия}.

\section{Реализация блокчейна}

Отмечу некоторые интересные моменты в моей реализации.

\subsection{Струтура кода}
Изначально я разбил файлы с исходным кодом на заголовочные, в которых я определил структуры, и файлы единиц трансляции, в которых находятся реализации.
\begin{itemize}
    \item Файлы \texttt{block.h}/\texttt{block.cpp} отвечают за структуру элементарного блока в блокчейне;
    \item файлы \texttt{blockchain.h}/\texttt{blockchain.cpp} отвечают за саму структуру блокчейна;
    \item в \texttt{json.h} находится header-only библиотека для работы с JSON;
    \item в \texttt{utils.h} определена функция \texttt{hash\_combine};
    \item в \texttt{main.cpp} находятся тесты и точка входа в программу.
\end{itemize}

\subsection{Хеширование}
Чтобы составить хеш-функцию, я отдельно считаю хеш-функции от временной метки, сообщения и nonce-значения через \href{https://en.cppreference.com/w/cpp/utility/hash}{std::hash}, а затем комбинирую их с хеш-значением предыдущемго блока с помощью функции \href{https://www.boost.org/doc/libs/1_74_0/boost/container_hash/hash.hpp}{combine\_hash} из библиотеки Boost.

\begin{lstlisting}
    hash_ = std::hash<std::string>{}(message);
    hash_combine(hash_, std::hash<std::time_t>{}(timestamp_));
    hash_combine(hash_, std::hash<std::uint64_t>{}(nonce));
    hash_combine(hash_, block.hash());
\end{lstlisting}

\subsection{Сериализация и десериализация}

Я сериализирую блокчейн в JSON документ с помощью header-only библиотеки \href{https://github.com/nlohmann/json}{nlohman::json}. Хранение данных в JSON списке позволяет удобно работать с отдельными блоками.

\begin{lstlisting}
    nlohmann::json Block::serialize() const {
        return nlohmann::json{
                {"message",   message_},
                {"nonce",     nonce_},
                {"hash",      hash_},
                {"timestamp", timestamp_}
        };
    }
\end{lstlisting}

\subsection{Синхронизация}
Среди приватных методов класса \texttt{BlockChain} есть функция \texttt{fork(index)}, которая копирует блокчейн с некоторого места и функция \texttt{mend(last\_correct, other)}, которая подменяет блоки в блокчейне, начиная с некоторого места (оставляя все, вплоть до блока с индексом \texttt{last\_correct}), на блоки блокчейна \texttt{other}.

\subsection{Тестирование}
В файле \texttt{main.cpp} находятся функции, тестирующие синхронизацию, а также проверяющие корректность работы сериализаторов и десериализаторов.

\end{document}
